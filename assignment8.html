<html>
<head>
    <script src=transformObj.js></script>
</head>
<body>
    Currently, rendering the sphere works properly. However, for some reason, only half of the torus is being displayed. It seems that half of it is being cut off in clip space
    <br />Still working on it
    <script>
        var gl, prog;
        function draw() {
            gl = document.getElementById('canvas1').getContext('experimental-webgl');
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);
            prog = gl.createProgram();
            function addShader(type, str) {
                var s = gl.createShader(type);
                gl.shaderSource(s, str);
                gl.compileShader(s);
                gl.attachShader(prog, s);
            }
            addShader(gl.VERTEX_SHADER, [
               , 'attribute vec3 aPos;'
               , 'uniform mat4 uMatrix;'
               , 'varying vec3 uPos;'
               , 'void main() {'
               , '   uPos = aPos;'
               , '   gl_Position = uMatrix * vec4(aPos, 1.);'
               , '}',
            ].join('\n')
            );
            addShader(gl.FRAGMENT_SHADER, [
               , 'precision highp float;'
               , 'varying vec3 uPos;'
               , 'void main() {'
               , '   gl_FragColor = vec4(vec3(0.,1.,1.) * (uPos.z < .5 ? uPos.z == -.5 ? .2 : .5 : 1.), 1.);'
               , '}',
            ].join('\n')
            );

            //triangleVertexPositionBuffer = gl.createBuffer();
            //gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
            //var vertices = [
            //     0.0, 1.0, 0.0,
            //    -1.0, -1.0, 0.0,
            //     1.0, -1.0, 0.0
            //];
            //gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            //triangleVertexPositionBuffer.itemSize = 3;
            //triangleVertexPositionBuffer.numItems = 3;

            var moonVertexPositionBuffer;
            var moonVertexNormalBuffer;
            var moonVertexTextureCoordBuffer;
            var moonVertexIndexBuffer;

            var latitudeBands = 30;
            var longitudeBands = 30;
            var radius = 0.5;

            var vertexPositionData = [];
            var normalData = [];
            var textureCoordData = [];
            var indexData = [];
            //for sphere
            for (var latNumber = 0; latNumber <= latitudeBands; latNumber++) {
                var theta = latNumber * 2 * Math.PI / latitudeBands;
                var sinTheta = Math.sin(theta);
                var cosTheta = Math.cos(theta);

                for (var longNumber = 0; longNumber <= longitudeBands; longNumber++) {
                    var phi = longNumber * 2 * Math.PI / longitudeBands;
                    var sinPhi = Math.sin(phi);
                    var cosPhi = Math.cos(phi);



                    //var theta = 2 * Math.PI * uv[0];
                    //var phi = 2 * Math.PI * uv[1];

                    //return [(1 + r * Math.cos(phi)) * Math.cos(theta),
                    //         (1 + r * Math.cos(phi)) * Math.sin(theta),
                    //              r * Math.sin(phi)];

               //     Math.cos(theta),
               //Math.sin(theta),
               // 2 * v - 1

                    //var x =  Math.cos(theta);
                    //var y = Math.sin(theta);
                    //var z = 2 * latNumber - 1;

                    var x = (1 + radius * Math.cos(phi)) * Math.cos(theta);
                    var y = (1 + radius * Math.cos(phi)) * Math.sin(theta);
                    var z = radius * Math.sin(phi);
                    var u = 1 - (longNumber / longitudeBands);
                    var v = 1 - (latNumber / latitudeBands);

                    normalData.push(x);
                    normalData.push(y);
                    normalData.push(z);
                    textureCoordData.push(u);
                    textureCoordData.push(v);
                    vertexPositionData.push(radius * x);
                    vertexPositionData.push(radius * y);
                    vertexPositionData.push(radius * z)
                }
            }

            for (var latNumber = 0; latNumber < latitudeBands; latNumber++) {
                for (var longNumber = 0; longNumber < longitudeBands; longNumber++) {
                    var first = (latNumber * (longitudeBands + 1)) + longNumber;
                    var second = first + longitudeBands + 1;
                    indexData.push(first);
                    indexData.push(second);
                    indexData.push(first + 1);

                    indexData.push(second);
                    indexData.push(second + 1);
                    indexData.push(first + 1);
                }
            }

            //moonVertexNormalBuffer = gl.createBuffer();
            //gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexNormalBuffer);
            //gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normalData), gl.STATIC_DRAW);
            //moonVertexNormalBuffer.itemSize = 3;
            //moonVertexNormalBuffer.numItems = normalData.length / 3;


            moonVertexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexPositionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), gl.STATIC_DRAW);
            moonVertexPositionBuffer.itemSize = 3;
            moonVertexPositionBuffer.numItems = vertexPositionData.length / 3;

            moonVertexIndexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, moonVertexIndexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), gl.STATIC_DRAW);
            moonVertexIndexBuffer.itemSize = 1;
            moonVertexIndexBuffer.numItems = indexData.length;




            //var vertices = [
            //   -.5,-.5, .5,
            //   -.5, .5, .5,
            //    .5,-.5, .5,
            //    .5, .5, .5,
            //    .5,-.5,-.5,
            //    .5, .5,-.5,
            //   -.5,-.5,-.5,
            //   -.5, .5,-.5,
            //   -.5,-.5, .5,
            //   -.5, .5, .5,
            //];




            function address(name) { return gl.getUniformLocation(prog, name); }
            gl.linkProgram(prog);
            //gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
            //gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            var attr = gl.getAttribLocation(prog, 'aPos');
            gl.enableVertexAttribArray(attr);
            gl.vertexAttribPointer(attr, 3, gl.FLOAT, false, 0, 0);
            gl.useProgram(prog);

            setInterval(tick, 1000 / 60);

            function tick() {
                var turn = (new Date()).getTime() / 1000.;
                var cos = Math.cos(turn);
                var sin = Math.sin(turn);
                var adjust = gl.canvas.height / gl.canvas.width;
                var matrix = [adjust * cos, 0, sin, .1 * sin,
                                        0, 1, 0, 0,
                              -adjust * sin, 0, cos, .1 * cos,
                                        0, 0, 0, 1];

                gl.uniformMatrix4fv(address('uMatrix'), false, matrix);
                gl.drawElements(gl.TRIANGLES, moonVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
                //gl.drawArrays(gl.TRIANGLE_STRIP, 0, vertices.length / 3);
            }
        }
        setTimeout(draw, 100);
    </script>
    <canvas id=canvas1 width=1000 height=1000></canvas>
</body>
</html>